<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="de">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta http-equiv="Content-Language" content="de_DE" />
    <link rel="stylesheet" type="text/css" href="../css.css" />
    <title>ghc-vis: Live visualization of data structures in GHCi</title>
  </head>
  <body>
    <h1>ghc-vis</h1>
    <ul>
      <li><a href="#introduction">Introduction</a></li>
      <li><a href="#basic-usage">Basic Usage</a></li>
      <li><a href="#more-examples">More Examples</a></li>
      <li><a href="#combined-debugger">Combined with GHCi's Debugger (Video example)</a></li>
      <li><a href="#as-library">Using ghc-vis as a Library</a></li>
      <li><a href="#issues">Bugs, Feature Requests, Development</a></li>
    </ul>
    <h2 id="introduction">Introduction</h2>
    <p>
      The GHCi Debugger has a :print command that inspects data structures at
      runtime. Evaluation is not forced, so there are no side effects.
    </p>
    <pre class="code">
$ ghci
GHCi, version 7.4.2: http://www.haskell.org/ghc/  :? for help
λ> let a = [1..3]
λ> :print a
a = (_t1::[Integer])
λ> head a
1
λ> :print a
a = 1 : (_t2::[Integer])
λ> head $ tail a
2
λ> :print a
a = 1 : 2 : (_t3::[Integer])
λ> a
[1,2,3]
λ> :print a
a = [1,2,3]
λ> let b = a ++ a
λ> head b
1
λ> :print b
b = 1 : (_t3::[Integer])
λ> b
[1,2,3,1,2,3]
λ> :print b
b = [1,2,3,1,2,3]</pre>
    <p>
      These data structures reside on the GHC heap. We can see that expressions
      are only evaluated once they are needed. This is called lazy evaluation.
      To avoid unnecessary copies of objects on the heap a heap object can be
      referenced multiple times instead of being copied into a new location.
      This is called sharing. We can see that :print does not tell us how b is
      sharing values with a or within itself.
    </p>
    <p>
      <a
      href="http://hackage.haskell.org/package/vacuum-cairo">Vacuum-cairo</a>
      on the other hand does tell us how values are shared within b:
    </p>
    <pre class="code">λ> System.Vacuum.Cairo.view b</pre>
    <p>
      The following window appears on the screen:<br/>
      <img alt="Demo" src="vacuum1.png"/>
    </p>
    <p>
      But vacuum-cairo evaluates the data structure fully before showing it. So
      we can't use it to see how data structures are lazily evaluated in
      Haskell.
    </p>
    <p>
      Additionally Vacuum-cairo is unable to visualize sharing between
      different data structures, like a and b in this case, as only one data
      structure can be viewed at any time. We would have to combine the data
      structures into one to see which values are referenced in both.
    </p>
    <p>
      When we use <a
      href="http://hackage.haskell.org/package/vacuum">vacuum</a> (and <a
      href="http://hackage.haskell.org/package/vacuum-graphviz">vacuum-graphviz</a>)
      directly we can inspect data structures without evaluating them:
    </p>
    <pre class="code">
λ> let a = "foo"
λ> let b = a ++ a
λ> head b
'f'
λ> GHC.Vacuum.GraphViz.graphToDotFile "vacuum2" Data.GraphViz.Commands.Png $ GHC.Vacuum.nameGraph (GHC.Vacuum.vacuumLazy (a,b))
    </pre>
    <p><img alt="Demo" src="vacuum2.png"/></p>
    <p>
      We can see that the value "C#l3" is referenced both in a and b. That's
      the 'f'. What we can't see is that the l5 thunk references a and has
      another value shared with a.
    </p>
    <p>
      What we'd like to see is something like this, which is what ghc-vis
      outputs:
    </p>
    <p><img alt="Demo" src="0.png"/></p>
    <h2 id="basic-usage">Basic usage</h2>
    <p>
      ghc-vis is a tool to visualize live Haskell data structures in GHCi.
      Evaluation is not forced and you can interact with the visualized data
      structures. This allows seeing Haskell's lazy evaluation and sharing in
      action.
    </p>
    <p>
      The <a href="http://hackage.haskell.org/package/ghc-vis">package</a> is
      available on Hackage. Install it like this:
    </p>
    <pre class="code">
$ cabal update
$ cabal install gtk2hs-buildtools
$ cabal install --disable-library-profiling ghc-vis
$ echo ":script $HOME/.cabal/share/ghc-vis-0.3.1/ghci" >> ~/.ghci</pre>
    <p>
      Now you can run ghci and experiment with ghc-vis. Start the
      visualization:
    </p>
    <pre class="code">
$ ghci
GHCi, version 7.4.2: http://www.haskell.org/ghc/  :? for help
λ> :vis</pre>
    <p>
      A blank window should appear now. This is the visualization window. Add
      an expression to the visualization:
    </p>
    <pre class="code">
λ> let a = [1..3]
λ> :view a
λ> let b = cycle a
λ> :view b
λ> :view "foo" ++ "bar"</pre>
    <p>
      You should now see something similar to this:<br/>
      <img alt="Demo" src="1.png" />
    </p>
    <p>
      Functions are red, named objects are green and links to an already shown
      object are blue.
    </p>
    <p>
      Notice how a is referenced by b.
    </p>
    <p>
      Evaluate an object that is shown in the visualization. You can also click
      on the object to evaluate it.
    </p>
    <pre class="code">λ> :eval t1</pre>
    <p><img alt="Demo" src="2.png" /></p>
    <p>
      The first element of b has been evaluated. We see that it's a reference
      to the value that's also referenced in a, as they share the same name
      "t0".
    </p>
    <p>
      Switch between the list view and the graph view:
    </p>
    <pre class="code">λ> :switch</pre>
    <p><img alt="Demo" src="3.png" /></p>
    <p>
      When an object is updated by accessing it, you have to call :update to
      refresh the visualization window. You can also click on an object to
      force an update:
    </p>
    <pre class="code">
λ> a !! 2
3
λ> :update</pre>
    <p><img alt="Demo" src="4.png" /></p>
    <p>
      Clear the visualization window, this also happens when you :load or
      :reload a source file:
    </p>
    <pre class="code">
λ> :clear</pre>
    <h2 id="more-examples">More Examples</h2>
    <pre class="code">
λ> let l = [1,2,3]
λ> :view l
λ> let l2 = 4:l
λ> :view l2
λ> let x = l ++ l2
λ> :view x
λ> let y = id (:) () y
λ> :view y
λ> :eval t3
λ> :switch</pre>
    <p><img alt="Demo" src="5.png" /> <img alt="Demo" src="6.png" /></p>
    <pre class="code">
λ> data BinaryTree = BT BinaryTree Int BinaryTree | Leaf
λ> let x = BT (BT (BT Leaf 1 (BT Leaf 2 Leaf)) 3 (BT (BT Leaf 4 (BT Leaf 5 Leaf)) 6 Leaf)) 7 Leaf
λ> :view x
λ> :switch</pre>
    <p><img alt="Demo" src="bt.png" /></p>
    <p>A working cyclic double linked list: <a href="dll.hs">dll.hs</a></p>
    <pre class="code">
λ> :l dll.hs
λ> let x = mkDList [1..4]
λ> :view x
λ> :switch</pre>
    <p><img alt="Demo" src="dll.png" /></p>
    <p>
      A non-working cyclic double linked list: <a href="dll2.hs">dll2.hs</a>
      New list elements get created all the time instead of referencing the
      existing ones.
    </p>
    <pre class="code">
λ> :l dll2.hs
λ> let x = mkDList [1..4]
λ> :view x
λ> :switch</pre>
    <p><img alt="Demo" src="dll2.png" /></p>
    <p><a href="dfa.hs">dfa.hs</a></p>
    <pre class="code">
λ> :l dfa.hs
λ> :view dom18
λ> :switch</pre>
    <p><img alt="Demo" src="dfa.png" /></p>
    <pre class="code">
λ> :view (Data.IntMap.fromList $ zip [1..10] [1..])
λ> :eval t0
λ> :switch</pre>
    <p><img alt="Demo" src="intmap.png" /></p>
    <pre class="code">
λ> let a = Data.ByteString.pack [0x44,0x45,0x46]
λ> :view a
λ> let b = Data.ByteString.append a a
λ> :view b
λ> :switch
λ> a
"DEF"
λ> :update</pre>
    <p><img alt="Demo" src="bytestring.png" /></p>
    <pre class="code">
λ> let b = GHC.Arr.array ((1,1),(3,2)) [((1,1),42),((1,2),23),((2,1),999),((2,2),1000),((3,1),1001),((3,2),1002)]
λ> b
array ((1,1),(3,2)) [((1,1),42),((1,2),23),((2,1),999),((2,2),1000),((3,1),1001),((3,2),1002)]
λ> :view b
λ> :switch</pre>
    <p><img alt="Demo" src="array.png" /></p>
    <h2 id="combined-debugger">Combined with GHCi's Debugger</h2>
    <p>
      ghc-vis can be used to watch data structures while a computation is
      inspected using GHCi's debugger:
    </p>
    <video width="640" height="480" controls>
      <source src="debugger.mp4" type="video/mp4" />
      <source src="debugger.webm" type="video/webm" />
      Your browser does not seem to support h264 videos, please down the video below.
    </video>
    <p><strong>Download Video:</strong> <a href="debugger.mp4">debugger.mp4</a>, <a href="debugger.webm">debugger.webm</a></p>
    <h2 id="as-library">Using ghc-vis as a Library</h2>
    <p>
      Although ghc-vis is meant to be used in GHCi it can also be used as a
      library in regular Haskell programs which are run or compiled by GHC. You
      can run those programs using "runghc example.hs" or "ghc -threaded
      example.hs && ./example". Without the "-threaded"-Flag ghc-vis does not work
      correctly. This is an example using ghc-vis outside of GHCi:
    </p>
    <pre class="code">
import GHC.Vis

main = do
  let a = "teeest"
  let b = [1..3]
  let c = b ++ b
  let d = [1..]
  putStrLn $ show $ d !! 1

  visualization
  view a "a"
  view b "b"
  view c "c"
  view d "d"

  getChar
  switch

  getChar</pre>
    <h2 id="issues">Bugs, Feature Requests, Development</h2>
    <p>
      If you have any problems, new ideas or comments concerning ghc-vis, just
      drop me an email: <a
      href="mailto:dennis@felsin9.de">dennis@felsin9.de</a>. I'll be glad to help you.
    </p>
  </body>
</html>
